% This file is automatically generated by mumax2-apigen. DO NOT EDIT.




\subsection{add\_to}
\label{add_to}
\index{add\_to}
\texttt{\textbf{add\_to}(sumQuantity, newQuantity)}\\
 Add a new quantity to the multi-physics engine, its\\
 value is added to the (existing) sumQuantity.\\
 E.g.: Add\_To("H", "H\_1") adds a new external field\\
 H\_1 that will be added to H.\\

\textbf{parameter types:}\\
sumQuantity : string \\
newQuantity : string \\


\subsection{add\_to\_weighted}
\label{add_to_weighted}
\index{add\_to\_weighted}
\texttt{\textbf{add\_to\_weighted}(sumQuantity, newQuantity, weight)}\\

\textbf{parameter types:}\\
sumQuantity : string \\
newQuantity : string \\
weight : float64 \\


\subsection{adddeltaquant}
\label{adddeltaquant}
\index{adddeltaquant}
\texttt{\textbf{adddeltaquant}(src, ref)}\\

\textbf{parameter types:}\\
src : string \\
ref : string \\


\subsection{autosave}
\label{autosave}
\index{autosave}
\texttt{\textbf{autosave}(quantity, format, options, period)}\\
 Saves a space-dependent quantity periodically, every period (expressed in seconds).\\
 Output appears in the output directory with automatically generated file names.\\
 E.g., for a quantity named "m", and format "txt" the generated files will be:\\
	m00000.txt m00001.txt m00002.txt...\\
 See FilenameFormat() for setting the number of zeros.\\
 Returns an integer handle that can be used to manipulate the auto-save entry.\\
 E.g. remove(handle) stops auto-saving it.\\
 @see filenumberfomat\\

\textbf{parameter types:}\\
quantity : string \\
format : string \\
options : []string \\
period : float64 \\
\textbf{returns:}
int 

\subsection{autosavesinglefile}
\label{autosavesinglefile}
\index{autosavesinglefile}
\texttt{\textbf{autosavesinglefile}(quantity, format, options, period)}\\
 Saves a space-dependent quantity periodically to a single file, every period (expressed in seconds).\\
 Output appears in the output directory with automatically generated file name.\\
 E.g., for a quantity named "m", and format "txt" the generated files will be:\\
 m.dump, b.dump ...\\
 See FilenameFormat() for setting the number of zeros.\\
 This function outputs to single file by appending new data to the end of the file.\\
 Therefore it is meaningfull only for mumax2's 'dump' binary format.\\
 Returns an integer handle that can be used to manipulate the auto-save entry.\\
 E.g. remove(handle) stops auto-saving it.\\
 @see filenumberfomat\\

\textbf{parameter types:}\\
quantity : string \\
format : string \\
options : []string \\
period : float64 \\
\textbf{returns:}
int 

\subsection{autotabulate}
\label{autotabulate}
\index{autotabulate}
\texttt{\textbf{autotabulate}(quantities, filename, period)}\\
 Saves any number of space-independent quantities periodically,\\
 every period (expressed in seconds).\\
 The values are appended to the file.\\
 Returns an integer handle that can be used to manipulate the auto-save entry.\\
 E.g. remove(handle) stops auto-saving it.\\

\textbf{parameter types:}\\
quantities : []string \\
filename : string \\
period : float64 \\
\textbf{returns:}
int 

\subsection{debug\_disableupdate}
\label{debug_disableupdate}
\index{debug\_disableupdate}
\texttt{\textbf{debug\_disableupdate}(quantity)}\\
 DEBUG: removes the updater of this quantity\\

\textbf{parameter types:}\\
quantity : string \\


\subsection{debug\_gc}
\label{debug_gc}
\index{debug\_gc}
\texttt{\textbf{debug\_gc}()}\\



\subsection{debug\_getarray}
\label{debug_getarray}
\index{debug\_getarray}
\texttt{\textbf{debug\_getarray}(quant)}\\
 FOR DEBUG ONLY.\\
 Gets the quantity's array, raw.\\

\textbf{parameter types:}\\
quant : string \\
\textbf{returns:}
*host.Array 

\subsection{debug\_invalidate}
\label{debug_invalidate}
\index{debug\_invalidate}
\texttt{\textbf{debug\_invalidate}(quantity)}\\
 DEBUG: manually update the quantity state\\

\textbf{parameter types:}\\
quantity : string \\


\subsection{debug\_update}
\label{debug_update}
\index{debug\_update}
\texttt{\textbf{debug\_update}(quantity)}\\
 DEBUG: manually update the quantity state\\

\textbf{parameter types:}\\
quantity : string \\


\subsection{debug\_verifyall}
\label{debug_verifyall}
\index{debug\_verifyall}
\texttt{\textbf{debug\_verifyall}()}\\
 DEBUG: verify all quanties' values\\



\subsection{debugfield}
\label{debugfield}
\index{debugfield}
\texttt{\textbf{debugfield}(quantity)}\\
 DEBUG: does not update\\

\textbf{parameter types:}\\
quantity : string \\
\textbf{returns:}
*host.Array 

\subsection{debugv}
\label{debugv}
\index{debugv}
\texttt{\textbf{debugv}(quantity)}\\
 DEBUG: Does not update.\\

\textbf{parameter types:}\\
quantity : string \\
\textbf{returns:}
\[\]float64 

\subsection{echo}
\label{echo}
\index{echo}
\texttt{\textbf{echo}(str)}\\
 DEBUG: echos a string, can be used for synchronous output\\

\textbf{parameter types:}\\
str : string \\


\subsection{filenumberformat}
\label{filenumberformat}
\index{filenumberformat}
\texttt{\textbf{filenumberformat}(format)}\\
 Sets a global C-style printf format string used to generate file names for automatically saved files.\\
 The default "%06d" generates, e.g., "m000001.txt". "%d" would generate, e.g., "m1.txt".\\

\textbf{parameter types:}\\
format : string \\


\subsection{getarray}
\label{getarray}
\index{getarray}
\texttt{\textbf{getarray}(quantity)}\\
 Gets a space-dependent quantity. If the quantity uses a mask,\\
 the result is equal to GetMask() * GetValue()\\

\textbf{parameter types:}\\
quantity : string \\
\textbf{returns:}
*host.Array 

\subsection{getcell}
\label{getcell}
\index{getcell}
\texttt{\textbf{getcell}(quant, x, y, z)}\\
 Gets the value of the quantity at cell position x,y,z\\

\textbf{parameter types:}\\
quant : string \\
x : int \\
y : int \\
z : int \\
\textbf{returns:}
\[\]float64 

\subsection{getcellsize}
\label{getcellsize}
\index{getcellsize}
\texttt{\textbf{getcellsize}()}\\
 Get the cell size.\\
 WARNING: convert to ZYX, internal units\\

\textbf{returns:}
float64 float64 float64 

\subsection{getdispersion}
\label{getdispersion}
\index{getdispersion}
\texttt{\textbf{getdispersion}(fmin, fmax, steps, format)}\\

\textbf{parameter types:}\\
fmin : float64 \\
fmax : float64 \\
steps : int \\
format : int \\


\subsection{getgridsize}
\label{getgridsize}
\index{getgridsize}
\texttt{\textbf{getgridsize}()}\\
 Get the grid size.\\
 WARNING: convert to ZYX\\

\textbf{returns:}
int int int 

\subsection{getmask}
\label{getmask}
\index{getmask}
\texttt{\textbf{getmask}(quantity)}\\
 Gets a space-dependent quantity. If the quantity uses a mask,\\
 the result is equal to GetMask() * GetValue()\\

\textbf{parameter types:}\\
quantity : string \\
\textbf{returns:}
*host.Array 

\subsection{getperiodic}
\label{getperiodic}
\index{getperiodic}
\texttt{\textbf{getperiodic}()}\\
 Get the periodicity\\
 WARNING: convert to ZYX, internal units\\

\textbf{returns:}
int int int 

\subsection{gets}
\label{gets}
\index{gets}
\texttt{\textbf{gets}(quantity)}\\
 Get the value of a scalar, space-independent quantity.\\
 Similar to GetValue, but returns a single number.\\

\textbf{parameter types:}\\
quantity : string \\
\textbf{returns:}
float64 

\subsection{getscalar}
\label{getscalar}
\index{getscalar}
\texttt{\textbf{getscalar}(quantity)}\\
 DEPRECATED: same as gets()\\

\textbf{parameter types:}\\
quantity : string \\
\textbf{returns:}
float64 

\subsection{gettime}
\label{gettime}
\index{gettime}
\texttt{\textbf{gettime}(tag)}\\
 DEBUG: Gets the time, in seconds, recorded by the timer with this tag.\\

\textbf{parameter types:}\\
tag : string \\
\textbf{returns:}
float64 

\subsection{getv}
\label{getv}
\index{getv}
\texttt{\textbf{getv}(quantity)}\\
 Get the value of a space-independent or masked quantity.\\
 Returns an array with vector components or an\\
 array with just one element in case of a scalar quantity.\\

\textbf{parameter types:}\\
quantity : string \\
\textbf{returns:}
\[\]float64 

\subsection{getvalue}
\label{getvalue}
\index{getvalue}
\texttt{\textbf{getvalue}(quantity)}\\
 DEPRECATED: same as getv()\\

\textbf{parameter types:}\\
quantity : string \\
\textbf{returns:}
\[\]float64 

\subsection{getworldsize}
\label{getworldsize}
\index{getworldsize}
\texttt{\textbf{getworldsize}()}\\
 Get the toal size, in meters, of the simulated world.\\

\textbf{returns:}
float64 float64 float64 

\subsection{load}
\label{load}
\index{load}
\texttt{\textbf{load}(name)}\\
 Load a physics module.\\

\textbf{parameter types:}\\
name : string \\


\subsection{loadargs}
\label{loadargs}
\index{loadargs}
\texttt{\textbf{loadargs}(name, ins, deps, outs)}\\
 Load a physics module with user-defined variables.\\

\textbf{parameter types:}\\
name : string \\
ins : []string \\
deps : []string \\
outs : []string \\


\subsection{new\_maxabs}
\label{new_maxabs}
\index{new\_maxabs}
\texttt{\textbf{new\_maxabs}(newQuantity, inputQuantity)}\\
 Add a new quantity to the multi-physics engine, its\\
 value is the maximum of the absolute value of inputQuantity.\\
 E.g.: New\_MaxAbs("max\_torque", "torque") adds a new quantity\\
 "max\_torque" whose value is max(abs(torque)). For vector\\
 quantities, the maximum is taken over all components.\\

\textbf{parameter types:}\\
newQuantity : string \\
inputQuantity : string \\


\subsection{new\_maxnorm}
\label{new_maxnorm}
\index{new\_maxnorm}
\texttt{\textbf{new\_maxnorm}(newQuantity, inputQuantity)}\\
 Add a new quantity to the multi-physics engine, its\\
 value is the maximum norm of inputQuantity (a 3-component vector).\\
 E.g.: New\_MaxNorm("maxnorm\_torque", "torque") adds a new quantity\\
 "maxnorm\_torque" whose value is max(norm(torque)).\\

\textbf{parameter types:}\\
newQuantity : string \\
inputQuantity : string \\


\subsection{new\_peak}
\label{new_peak}
\index{new\_peak}
\texttt{\textbf{new\_peak}(newQuantity, inputQuantity)}\\

\textbf{parameter types:}\\
newQuantity : string \\
inputQuantity : string \\


\subsection{outputdirectory}
\label{outputdirectory}
\index{outputdirectory}
\texttt{\textbf{outputdirectory}()}\\
 Returns the output directory for the running simulation.\\

\textbf{returns:}
string 

\subsection{outputid}
\label{outputid}
\index{outputid}
\texttt{\textbf{outputid}()}\\
 Returns the output ID corresponding to the current simulation time.\\
 All automatic output uses this number to identify the time corresponding\\
 to the saved quantity.\\

\textbf{returns:}
int 

\subsection{printstats}
\label{printstats}
\index{printstats}
\texttt{\textbf{printstats}()}\\
 DEBUG\\



\subsection{readfile}
\label{readfile}
\index{readfile}
\texttt{\textbf{readfile}(filename)}\\
 DEBUG: reads an array from a file.\\

\textbf{parameter types:}\\
filename : string \\
\textbf{returns:}
*host.Array 

\subsection{recoverstate}
\label{recoverstate}
\index{recoverstate}
\texttt{\textbf{recoverstate}(dst, src)}\\

\textbf{parameter types:}\\
dst : string \\
src : string \\


\subsection{remove}
\label{remove}
\index{remove}
\texttt{\textbf{remove}(handle)}\\
 Removes the object with given handle.\\
 E.g.:\\
	handle = autosave(...)\\
	remove(handle) \# stops auto-saving\\

\textbf{parameter types:}\\
handle : int \\


\subsection{resettimer}
\label{resettimer}
\index{resettimer}
\texttt{\textbf{resettimer}(tag)}\\
 DEBUG: Resets the timer with this tag.\\

\textbf{parameter types:}\\
tag : string \\


\subsection{run}
\label{run}
\index{run}
\texttt{\textbf{run}(duration)}\\
 Runs for a duration given in seconds.\\
 TODO: precise stopping time\\

\textbf{parameter types:}\\
duration : float64 \\


\subsection{run\_until\_larger}
\label{run_until_larger}
\index{run\_until\_larger}
\texttt{\textbf{run\_until\_larger}(quantity, value)}\\
 Runs the simulation until quantity a > quantity b\\

\textbf{parameter types:}\\
quantity : string \\
value : float64 \\


\subsection{run\_until\_smaller}
\label{run_until_smaller}
\index{run\_until\_smaller}
\texttt{\textbf{run\_until\_smaller}(quantity, value)}\\
 Runs the simulation until quantity a < value\\

\textbf{parameter types:}\\
quantity : string \\
value : float64 \\


\subsection{save}
\label{save}
\index{save}
\texttt{\textbf{save}(quantity, format, options)}\\
 Saves a space-dependent quantity, once. Uses the specified format and gives an automatic file name (like "m000001.png").\\
 See also: Save()\\

\textbf{parameter types:}\\
quantity : string \\
format : string \\
options : []string \\


\subsection{saveas}
\label{saveas}
\index{saveas}
\texttt{\textbf{saveas}(quantity, format, options, filename)}\\
 Saves a space-dependent quantity, once. Uses the specified format and file name.\\

\textbf{parameter types:}\\
quantity : string \\
format : string \\
options : []string \\
filename : string \\


\subsection{savegraph}
\label{savegraph}
\index{savegraph}
\texttt{\textbf{savegraph}(file)}\\
 Saves an image file of the physics graph using the given file name.\\
 The extension determines the output format. E.g.: .png, .svg, ...\\
 A file with a .dot extension will be written as well.\\
 Rendering requires the package "graphviz" to be installed.\\

\textbf{parameter types:}\\
file : string \\


\subsection{savestate}
\label{savestate}
\index{savestate}
\texttt{\textbf{savestate}(dst, src)}\\

\textbf{parameter types:}\\
dst : string \\
src : string \\


\subsection{setarray}
\label{setarray}
\index{setarray}
\texttt{\textbf{setarray}(quantity, field)}\\
 Sets a space-dependent field quantity, like the magnetization.\\

\textbf{parameter types:}\\
quantity : string \\
field : *host.Array \\


\subsection{setarray\_file}
\label{setarray_file}
\index{setarray\_file}
\texttt{\textbf{setarray\_file}(quantity, filename)}\\
 Like SetArray but reads the array from a file.\\

\textbf{parameter types:}\\
quantity : string \\
filename : string \\


\subsection{setcell}
\label{setcell}
\index{setcell}
\texttt{\textbf{setcell}(quant, x, y, z, value)}\\
 Sets the value of the quantity at cell position x,y,z\\

\textbf{parameter types:}\\
quant : string \\
x : int \\
y : int \\
z : int \\
value : []float64 \\


\subsection{setcellsize}
\label{setcellsize}
\index{setcellsize}
\texttt{\textbf{setcellsize}(x, y, z)}\\
 Set the cell size.\\
 WARNING: convert to ZYX\\

\textbf{parameter types:}\\
x : float64 \\
y : float64 \\
z : float64 \\


\subsection{setgridsize}
\label{setgridsize}
\index{setgridsize}
\texttt{\textbf{setgridsize}(x, y, z)}\\
 Set the grid size.\\
 WARNING: convert to ZYX\\

\textbf{parameter types:}\\
x : int \\
y : int \\
z : int \\


\subsection{setmask}
\label{setmask}
\index{setmask}
\texttt{\textbf{setmask}(quantity, mask)}\\
 Sets a space-dependent multiplier mask for the quantity.\\
 The value of the quantity (set by SetValue), will be multiplied\\
 by the mask value in each point of space. The mask is dimensionless\\
 and typically contains values between 0 and 1.\\

\textbf{parameter types:}\\
quantity : string \\
mask : *host.Array \\


\subsection{setmask\_file}
\label{setmask_file}
\index{setmask\_file}
\texttt{\textbf{setmask\_file}(quantity, filename)}\\
 Like SetMask but reads the mask from a file.\\

\textbf{parameter types:}\\
quantity : string \\
filename : string \\


\subsection{setperiodic}
\label{setperiodic}
\index{setperiodic}
\texttt{\textbf{setperiodic}(x, y, z)}\\
 Set periodic boundary conditions in each direction.\\
 A value of 0 means no periodicity in that direction (the default).\\
 A nonzero value means the system is infinitely reproduced in that direction.\\
 The magnitude of the nonzero value is a hint of how accurately the\\
 infinite character should be approached, if applicable.\\
 E.g.: for the ferromagnetic exchange interaction,\\
 any nonzero value will give the same result: perfect infinite periodicity.\\
 But for the magnetostatic interaction, the magnitude of the nonzero value\\
 may be used as a hint where to cut off the magnetic field.\\

\textbf{parameter types:}\\
x : int \\
y : int \\
z : int \\


\subsection{setpointwise}
\label{setpointwise}
\index{setpointwise}
\texttt{\textbf{setpointwise}(quantity, time, value)}\\
 Used to set a quantity as a function of time. Usage:\\
	SetPointwise("Quant", time0, \[value0\])\\
	SetPointwise("Quant", time1, \[value1\])\\
	SetPointwise("Quant", time2, \[value2\])\\
	...\\
 Will make the quantity vary as a function of time, using\\
 piecewise linear interpolation between the defined time-value pairs.\\
 It is a good idea to end with something like:\\
	SetPointwise("Quant", 9999, \[0\])\\
 to define the value as zero for time = infinity (after a pulse, e.g.),\\
 because the function has to be defined during the entire simulation.\\

\textbf{parameter types:}\\
quantity : string \\
time : float64 \\
value : []float64 \\


\subsection{setpointwiseof}
\label{setpointwiseof}
\index{setpointwiseof}
\texttt{\textbf{setpointwiseof}(argument, quantity, arg, value)}\\

\textbf{parameter types:}\\
argument : string \\
quantity : string \\
arg : float64 \\
value : []float64 \\


\subsection{sets}
\label{sets}
\index{sets}
\texttt{\textbf{sets}(quantity, value)}\\
 Set scalar. Convenience method for SetValue() with only one number.\\
 REDUNDANT?\\

\textbf{parameter types:}\\
quantity : string \\
value : float64 \\


\subsection{setscalar}
\label{setscalar}
\index{setscalar}
\texttt{\textbf{setscalar}(quantity, value)}\\

\textbf{parameter types:}\\
quantity : string \\
value : float64 \\


\subsection{setv}
\label{setv}
\index{setv}
\texttt{\textbf{setv}(quantity, value)}\\
 Set value of a quantity. The quantity must be of type VALUE or MASK.\\
 If the quantity is a MASK, the value will be multiplied by a space-dependent mask\\
 which typically contains dimensionless numbers between 0 and 1.\\

\textbf{parameter types:}\\
quantity : string \\
value : []float64 \\


\subsection{setvalue}
\label{setvalue}
\index{setvalue}
\texttt{\textbf{setvalue}(quantity, value)}\\

\textbf{parameter types:}\\
quantity : string \\
value : []float64 \\


\subsection{starttimer}
\label{starttimer}
\index{starttimer}
\texttt{\textbf{starttimer}(tag)}\\
 DEBUG: start a timer with a given identifier tag\\

\textbf{parameter types:}\\
tag : string \\


\subsection{step}
\label{step}
\index{step}
\texttt{\textbf{step}()}\\
 Take one solver step\\



\subsection{steps}
\label{steps}
\index{steps}
\texttt{\textbf{steps}(N)}\\
 Takes N solver steps\\

\textbf{parameter types:}\\
N : int \\


\subsection{stoptimer}
\label{stoptimer}
\index{stoptimer}
\texttt{\textbf{stoptimer}(tag)}\\
 DEBUG: stop a timer with a given identifier tag.\\
 It must be started first.\\

\textbf{parameter types:}\\
tag : string \\


\subsection{sync}
\label{sync}
\index{sync}
\texttt{\textbf{sync}()}\\
 Should be called at the end of each input file to make\\
 sure the input script does not terminate too early.\\



\subsection{tabulate}
\label{tabulate}
\index{tabulate}
\texttt{\textbf{tabulate}(quantities, filename)}\\
 Saves these space-independent quantities, once.\\
 Their values are appended to the file, on one line.\\

\textbf{parameter types:}\\
quantities : []string \\
filename : string \\


\subsection{unit}
\label{unit}
\index{unit}
\texttt{\textbf{unit}(quantity)}\\
 Gets the quantities unit.\\

\textbf{parameter types:}\\
quantity : string \\
\textbf{returns:}
string 
